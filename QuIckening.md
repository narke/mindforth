AiEvolution MileStones ReJuvenate RoadMap UserManual

### Definition ###

_Quickening_ is the stage in AGI development when the main
software module of the AGI comes alive as a program that
runs continuously. We derive the term quickening from the
notion of the quick and the dead as opposites, and from the
idea of the quickening in the womb, when an expectant
mother begins to feel the movements of the baby growing
within her.

AGI development is different from other software
development. If you write a program that performs a single
operation and then stops, the software does not quicken and
come alive. If you write a chess program that answers your
every move with a move of its own, the software does not
quicken, because the software does not hum with activity
while it waits for you. If you write a home-monitoring
software system that constantly checks your burglar-alarm
system and the temperature and the presence or absence of
smoke in the air, that software has not truly quickened
because it is only passively waiting for something to
happen, like a word-processor waiting for you to type in a
word.

When you are creating an artificial general intelligence
(AGI), at some point the software has to quicken by running
indefinitely. An AGI has to iterate endlessly through its
MainLoop or the equivalent thereof. It must not run one
time and then stop. It must be a form of artificial life
(alife).

The early milestone stage of Quickening is not hard to
achieve, but it does draw out from you some careful
planning, such as in the area of what sort of modules you
want to be the constituent parts of your fullblown AGI. To
get your AGI software to quicken, you only need to stub in
most of the modules and to elaborate at least one of the
modules to get the AGI to exhibit some rudimentary behavior
that will demonstrate the quickening. Any module for the
user interface is a good one to code more profoundly than
the mere stubs, because the user interface makes it obvious
that something is happening inside the AGI. The event
happening in the AGI may not yet be thinking or self-awareness
or SuperIntelligence, but you may have the user
interface do something like counting elapsed time or
declaring various system parameters such as available
memory space or open channels of communication.
As in human evolution, where ontogeny recapitulates
phylogeny and therefore a baby in the womb goes through
fishlike stages that disappear before a human being is
born, your neonatal AGI may include software elements that
you will remove as the AGI matures. Beware, however, of one
trap. Do not let the performance of the AGI software be
dependent on the presence of input from a human user. Your
emerging AGI is not some unintelligent, idiot word-
processor. Only give the human user a window of
opportunity to enter input or to communicate somehow (send
a tweet?) with the machine intelligence. Slam the window
shut periodically and let the AGI do its own thing for a
few looping cycles. Then check again for user input. Let
nothing be a show-stopper. Eventually your AGI, or
somebody's AGI, is going to outlive all human beings
currently alive on this planet. Get used to it, get over
it, and get on with it.

### Variations ###

Normally the software of an artificial mind a first time
and then many other times in the course of trial runs,
especially during PortingOfCode from one programming
language to another. If the AiMind were coded in a
Dylanesque dynamic language that can be changed on the fly,
conceivably an AI could quicken at a young age and continue
running even as modifications were performed on the running
code.

Although Quickening starts when the Mind program runs
indefinitely, Quickening fails if the AiMind runs out of
memory space. As a mind designer you have two choices: A)
provide infinite memory; or B) provide infinite looping. If
you are a deity designing human beings, you only need to
provide enough memory for a lifetime. You may be designing
a potentially immortal AiMind, in which case, God, that's a
hard one. You work wonders in mysterious ways, but
we mortal human beings must design our immortal successor
species more pragmatically. Since the MainLoop itself does
not have infinite memory at its disposal, we use the
ReJuvenate module to loop through a finite memory space as
if it were immortal, I mean, infinite. The larger the
memory space in the AiMind, the less frequently the
ReJuvenate module has to kick in. If computer memory
becomes really cheap and plentiful, or if the
PermanentInstallation of a mission-critical AI entity
warrants astronomical quantities of memory no matter what
the cost, an AiMind could dispense with the ReJuvenate
module and not worry about running out of memory in the far
and distant future long after the first stirring and
quickening of the AI Mind.


### OutReach ###

http://agi-roadmap.org/Quickening is the open,
collaborative page where you may contribute your own ideas
and use the associated Talk page for discussion.

### MemeSpace ###
AdminisTrivia AiEvolution BottomUp CodeComplete ImMortality LifeQuaScienceFiction MindGrid PermanentInstallation ReJuvenate TippingPoint UserManual